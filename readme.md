# leetcode 刷题  每日至少一题
    开始时间 20210523
    @倩男 又成了我一个人刷题 终究还是我一个人抗下了所有 

`先刷动态规划吧`

### 20210523
* 题目描述给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最 小的路径。每次只能向右或者向下移动
  
* 输入输出样例
    输入是一个二维数组，输出是最优路径的数字和。
  

*转移方程 
dp[i][j] = min(dp[i-1][j] , dp[i][j-1]) + path[i][j]




/**
* 题目描述
* 给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。
* 输入输出样例
* 输入是一个二维 0-1 数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的 0
* 两次循环
*      1、先找右和下距离 0 最近的位置 赋值当前dp
*      2、再找左和上距离0最近的位置 同时更新当前dp
*
* https://leetcode-cn.com/problems/01-matrix/solution/2chong-bfs-xiang-jie-dp-bi-xu-miao-dong-by-sweetie/
*
* 分别从左上 右下 扫描
* @return
*/



/**
* 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
*
* 转移方程 ：
*  当当前位置为1时 找到当前位置所在的其他三个位置中最小的值 加上1就是当前最小的面积
*  当前如果刚好在边上 dp[i][j] = 1
*  dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1
*
*  找到边长后  平方就是最大面积
* @param matrix
* @return
*


    `20210524   组成n的最小平平方个数`

* 最大平方数 和 零钱很像
*
* 思路
*   dp[i] 表示当前这个数 如dpp[12] = 12 ；
*   当前数最差由 n个1组成 所以第一次dp[i] = i
*   内层 i-j*j >= 0 表示当前j的平方能否组成<=i
*   Math.min(dp[i],dp[i - j*j ] + 1 )表示
*   比如10 可以由 3*3+1 或者说由dp[6]+2*2  也就是dp[1] + 3*3 后面+1表示当前j*j是1次
*   dp[6]中存储这组成6的最小平方数的个数




    20210525
    找零钱为题 
    、首先将原问题拆分为子问题
    
    已知什么？显而易见，钞票的金额都只需要其本身1张即可
    
    如何在已知钞票的情况下构造出 金额X需要的最少钞票组合
    
    2、确认状态
    
    　　DP[0] - DP[amount] 表示构造金额amount需要的最小钞票数
    
    3、确认边界状态（初试条件）
    
    DP[coin] = 1 其他的都未知初始值设为 -1
    
    例如coins = [1, 2, 5], amount = 11 已知 dp[1]、dp[2]、dp[5] =1
    
    现在已知 DP[coin] 需要求出每一个DP[amount]
    
    4、状态转移方程
    
    　　dp[i] = min(dp[i-1], dp[i-2], dp[i-5]) + 1



